// **********************************************************************
// This file was generated by a TAF parser!
// TAF version 2.1.4.2 by WSRD Tencent.
// Generated from `/usr/local/resin_system.mqq.com/webapps/communication/taf/upload/bredzhang/reportLog.jce'
// **********************************************************************

#include "reportLog.h"

extern int pdu_header_pack1(pdu_protocol_header * pdu_header, uint8_t * pui_buff, uint32_t * pi_buff_len);
extern int pdu_header_pack2(uint8_t * pui_buff, uint32_t * pi_buff_len, uint32_t * pi_used_len);
extern int pdu_header_unpack(uint8_t * pui_buff, uint32_t * pi_buff_len, pdu_protocol_header * pdu_header, uint32_t * pi_end_len);

namespace cannon
{

    int struct_ReportInfo_Log_pack(ReportInfo_Log * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_ReportInfo_Log_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, ReportInfo_Log * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_ReportInfo_Log_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, ReportInfo_Log * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_ReportInfo_Log_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_ReportInfo_Log_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, ReportInfo_Log * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_ReportInfo_Log_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_ReportInfo_pack(ReportInfo * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_ReportInfo_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, ReportInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_ReportInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, ReportInfo * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_ReportInfo_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_ReportInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, ReportInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_ReportInfo_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_LogControlReq_pack(LogControlReq * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_LogControlReq_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, LogControlReq * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_LogControlReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, LogControlReq * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_LogControlReq_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_LogControlReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, LogControlReq * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_LogControlReq_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_LogUploadReq_pack(LogUploadReq * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_LogUploadReq_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, LogUploadReq * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_LogUploadReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, LogUploadReq * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_LogUploadReq_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_LogUploadReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, LogUploadReq * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_LogUploadReq_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


}

