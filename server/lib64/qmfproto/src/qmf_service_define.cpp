// **********************************************************************
// This file was generated by a TAF parser!
// TAF version 3.0.0.20 by WSRD Tencent.
// Generated from `/usr/local/resin_system.mqq.com/webapps/communication/taf/upload/zahirpeng/qmf_service_define.jce'
// **********************************************************************

#include "qmf_service_define.h"

extern int pdu_header_pack1(pdu_protocol_header * pdu_header, uint8_t * pui_buff, uint32_t * pi_buff_len);
extern int pdu_header_pack2(uint8_t * pui_buff, uint32_t * pi_buff_len, uint32_t * pi_used_len);
extern int pdu_header_unpack(uint8_t * pui_buff, uint32_t * pi_buff_len, pdu_protocol_header * pdu_header, uint32_t * pi_end_len);

namespace QMF_SERVICE
{

    int struct_WnsCmdLoginReq_pack(WnsCmdLoginReq * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_WnsCmdLoginReq_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdLoginReq * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_WnsCmdLoginReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdLoginReq * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_WnsCmdLoginReq_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_WnsCmdLoginReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdLoginReq * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_WnsCmdLoginReq_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_WnsCmdLoginRsp_pack(WnsCmdLoginRsp * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_WnsCmdLoginRsp_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdLoginRsp * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_WnsCmdLoginRsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdLoginRsp * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_WnsCmdLoginRsp_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_WnsCmdLoginRsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdLoginRsp * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_WnsCmdLoginRsp_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_SdkConnMgrInfo_pack(SdkConnMgrInfo * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_SdkConnMgrInfo_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, SdkConnMgrInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_SdkConnMgrInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, SdkConnMgrInfo * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_SdkConnMgrInfo_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_SdkConnMgrInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, SdkConnMgrInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_SdkConnMgrInfo_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_WnsCmdHeartBeat_pack(WnsCmdHeartBeat * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_WnsCmdHeartBeat_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdHeartBeat * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_WnsCmdHeartBeat_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdHeartBeat * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_WnsCmdHeartBeat_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_WnsCmdHeartBeat_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdHeartBeat * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_WnsCmdHeartBeat_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_WnsCmdLoginOff_pack(WnsCmdLoginOff * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_WnsCmdLoginOff_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdLoginOff * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_WnsCmdLoginOff_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdLoginOff * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_WnsCmdLoginOff_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_WnsCmdLoginOff_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdLoginOff * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_WnsCmdLoginOff_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_WnsIpInfo_pack(WnsIpInfo * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_WnsIpInfo_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, WnsIpInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_WnsIpInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsIpInfo * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_WnsIpInfo_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_WnsIpInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsIpInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_WnsIpInfo_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_WnsCmdHandShakeReq_pack(WnsCmdHandShakeReq * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_WnsCmdHandShakeReq_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdHandShakeReq * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_WnsCmdHandShakeReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdHandShakeReq * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_WnsCmdHandShakeReq_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_WnsCmdHandShakeReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdHandShakeReq * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_WnsCmdHandShakeReq_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_WnsCmdHandShakeRsp_pack(WnsCmdHandShakeRsp * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_WnsCmdHandShakeRsp_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdHandShakeRsp * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_WnsCmdHandShakeRsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdHandShakeRsp * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_WnsCmdHandShakeRsp_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_WnsCmdHandShakeRsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdHandShakeRsp * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_WnsCmdHandShakeRsp_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_WnsCmdServerListRsp_pack(WnsCmdServerListRsp * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_WnsCmdServerListRsp_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdServerListRsp * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_WnsCmdServerListRsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdServerListRsp * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_WnsCmdServerListRsp_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_WnsCmdServerListRsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdServerListRsp * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_WnsCmdServerListRsp_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_WnsSpeedLatencyInfo_pack(WnsSpeedLatencyInfo * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_WnsSpeedLatencyInfo_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, WnsSpeedLatencyInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_WnsSpeedLatencyInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsSpeedLatencyInfo * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_WnsSpeedLatencyInfo_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_WnsSpeedLatencyInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsSpeedLatencyInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_WnsSpeedLatencyInfo_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_WnsReportTestIpInfo_pack(WnsReportTestIpInfo * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_WnsReportTestIpInfo_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, WnsReportTestIpInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_WnsReportTestIpInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsReportTestIpInfo * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_WnsReportTestIpInfo_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_WnsReportTestIpInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsReportTestIpInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_WnsReportTestIpInfo_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_WnsCmdSpeed4TestReq_pack(WnsCmdSpeed4TestReq * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_WnsCmdSpeed4TestReq_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdSpeed4TestReq * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_WnsCmdSpeed4TestReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdSpeed4TestReq * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_WnsCmdSpeed4TestReq_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_WnsCmdSpeed4TestReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdSpeed4TestReq * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_WnsCmdSpeed4TestReq_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_WnsCmdSettingReq_pack(WnsCmdSettingReq * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_WnsCmdSettingReq_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdSettingReq * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_WnsCmdSettingReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdSettingReq * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_WnsCmdSettingReq_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_WnsCmdSettingReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdSettingReq * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_WnsCmdSettingReq_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_WnsCmdSettingRsp_pack(WnsCmdSettingRsp * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_WnsCmdSettingRsp_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdSettingRsp * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_WnsCmdSettingRsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdSettingRsp * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_WnsCmdSettingRsp_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_WnsCmdSettingRsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdSettingRsp * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_WnsCmdSettingRsp_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_WnsCmdPushRegisterReq_pack(WnsCmdPushRegisterReq * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_WnsCmdPushRegisterReq_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdPushRegisterReq * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_WnsCmdPushRegisterReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdPushRegisterReq * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_WnsCmdPushRegisterReq_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_WnsCmdPushRegisterReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdPushRegisterReq * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_WnsCmdPushRegisterReq_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_WnsCmdPushRegisterRsp_pack(WnsCmdPushRegisterRsp * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_WnsCmdPushRegisterRsp_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdPushRegisterRsp * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_WnsCmdPushRegisterRsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdPushRegisterRsp * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_WnsCmdPushRegisterRsp_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_WnsCmdPushRegisterRsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdPushRegisterRsp * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_WnsCmdPushRegisterRsp_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_WnsSpeedTestIpInfo_pack(WnsSpeedTestIpInfo * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_WnsSpeedTestIpInfo_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, WnsSpeedTestIpInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_WnsSpeedTestIpInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsSpeedTestIpInfo * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_WnsSpeedTestIpInfo_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_WnsSpeedTestIpInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsSpeedTestIpInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_WnsSpeedTestIpInfo_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_WnsCmdGetTestSpeedIpListReq_pack(WnsCmdGetTestSpeedIpListReq * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_WnsCmdGetTestSpeedIpListReq_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdGetTestSpeedIpListReq * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_WnsCmdGetTestSpeedIpListReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdGetTestSpeedIpListReq * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_WnsCmdGetTestSpeedIpListReq_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_WnsCmdGetTestSpeedIpListReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdGetTestSpeedIpListReq * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_WnsCmdGetTestSpeedIpListReq_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_WnsCmdGetTestSpeedIpListRsp_pack(WnsCmdGetTestSpeedIpListRsp * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_WnsCmdGetTestSpeedIpListRsp_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdGetTestSpeedIpListRsp * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_WnsCmdGetTestSpeedIpListRsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdGetTestSpeedIpListRsp * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_WnsCmdGetTestSpeedIpListRsp_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_WnsCmdGetTestSpeedIpListRsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdGetTestSpeedIpListRsp * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_WnsCmdGetTestSpeedIpListRsp_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


}

namespace QMF_LOG
{

    int struct_LogInfo_pack(LogInfo * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_LogInfo_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, LogInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_LogInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, LogInfo * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_LogInfo_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_LogInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, LogInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_LogInfo_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_WnsCmdReportLog_pack(WnsCmdReportLog * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_WnsCmdReportLog_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdReportLog * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_WnsCmdReportLog_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdReportLog * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_WnsCmdReportLog_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_WnsCmdReportLog_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdReportLog * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_WnsCmdReportLog_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_WnsCmdLogControlReq_pack(WnsCmdLogControlReq * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_WnsCmdLogControlReq_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdLogControlReq * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_WnsCmdLogControlReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdLogControlReq * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_WnsCmdLogControlReq_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_WnsCmdLogControlReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdLogControlReq * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_WnsCmdLogControlReq_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_WnsCmdLogControlRsp_pack(WnsCmdLogControlRsp * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_WnsCmdLogControlRsp_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdLogControlRsp * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_WnsCmdLogControlRsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdLogControlRsp * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_WnsCmdLogControlRsp_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_WnsCmdLogControlRsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdLogControlRsp * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_WnsCmdLogControlRsp_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_WnsCmdLogUploadReq_pack(WnsCmdLogUploadReq * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_WnsCmdLogUploadReq_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdLogUploadReq * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_WnsCmdLogUploadReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdLogUploadReq * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_WnsCmdLogUploadReq_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_WnsCmdLogUploadReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdLogUploadReq * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_WnsCmdLogUploadReq_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_WnsCmdLogUploadRsp_pack(WnsCmdLogUploadRsp * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_WnsCmdLogUploadRsp_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdLogUploadRsp * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_WnsCmdLogUploadRsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdLogUploadRsp * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_WnsCmdLogUploadRsp_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_WnsCmdLogUploadRsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdLogUploadRsp * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_WnsCmdLogUploadRsp_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


}

namespace PUSHAPI
{

    int struct_stSwitch_pack(stSwitch * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_stSwitch_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, stSwitch * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_stSwitch_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, stSwitch * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_stSwitch_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_stSwitch_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, stSwitch * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_stSwitch_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_STStatus_pack(STStatus * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_STStatus_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, STStatus * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_STStatus_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, STStatus * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_STStatus_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_STStatus_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, STStatus * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_STStatus_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_StatusInfo_pack(StatusInfo * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_StatusInfo_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, StatusInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_StatusInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, StatusInfo * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_StatusInfo_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_StatusInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, StatusInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_StatusInfo_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_GetStatusInfo_pack(GetStatusInfo * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_GetStatusInfo_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, GetStatusInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_GetStatusInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, GetStatusInfo * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_GetStatusInfo_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_GetStatusInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, GetStatusInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_GetStatusInfo_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_DeviceInfo_pack(DeviceInfo * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_DeviceInfo_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, DeviceInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_DeviceInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, DeviceInfo * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_DeviceInfo_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_DeviceInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, DeviceInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_DeviceInfo_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_PushInfo_pack(PushInfo * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_PushInfo_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, PushInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_PushInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, PushInfo * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_PushInfo_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_PushInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, PushInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_PushInfo_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_STMsg_pack(STMsg * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_STMsg_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, STMsg * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_STMsg_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, STMsg * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_STMsg_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_STMsg_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, STMsg * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_STMsg_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_MsgInfo_pack(MsgInfo * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_MsgInfo_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, MsgInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_MsgInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, MsgInfo * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_MsgInfo_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_MsgInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, MsgInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_MsgInfo_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_Push_pack(Push * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_Push_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, Push * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_Push_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, Push * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_Push_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_Push_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, Push * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_Push_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_PushRsp_pack(PushRsp * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_PushRsp_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, PushRsp * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_PushRsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, PushRsp * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_PushRsp_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_PushRsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, PushRsp * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_PushRsp_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_IOSPush_pack(IOSPush * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_IOSPush_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, IOSPush * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_IOSPush_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, IOSPush * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_IOSPush_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_IOSPush_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, IOSPush * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_IOSPush_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_WINMsg_pack(WINMsg * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_WINMsg_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, WINMsg * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_WINMsg_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WINMsg * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_WINMsg_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_WINMsg_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WINMsg * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_WINMsg_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


    int struct_WINPush_pack(WINPush * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
    {
        try
        {
            int i_len = pdu_header?*pi_buff_len:0;
            int i_ret = 0;
            if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

            taf::JceOutputStream<taf::BufferWriterBuff> os;
            os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
            pst_struct->writeTo(os);
            i_len = i_len + static_cast<int>(os.getLength());
            if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
            *pi_buff_len = i_len;
        }
        catch (taf::JceNotEnoughBuff & e)
        {
            return -100;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }

    static int struct_WINPush_unpack__(uint8_t * pui_buff, int32_t * pi_buff_len, WINPush * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        try
        {
            int i_ret = 0;
            int i_wup_len = pdu_header?*pi_buff_len:0;
            int i_end_len = 0;
            if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

            taf::JceInputStream<taf::MapBufferReader> is;
            is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));
            if (pui_mapbuff && pi_mapbuff_len) is.setMapBuffer((char *)pui_mapbuff, *pi_mapbuff_len);

            pst_struct->readFrom(is);
        }
        catch (taf::JceDecodeMismatch & e)
        {
            return -101;
        }
        catch (taf::JceDecodeInvalidValue & e)
        {
            return -104;
        }
        catch (taf::JceDecodeRequireNotExist & e)
        {
            return -103;
        }
        catch (...)
        {
            return -1;
        }
        return 0;
    }
    int struct_WINPush_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WINPush * pst_struct, pdu_protocol_header * pdu_header)
    {
        return struct_WINPush_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, NULL, NULL);
    }

    int struct_WINPush_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WINPush * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len)
    {
        return struct_WINPush_unpack__(pui_buff, pi_buff_len, pst_struct, pdu_header, pui_mapbuff, pi_mapbuff_len);
    }


}

