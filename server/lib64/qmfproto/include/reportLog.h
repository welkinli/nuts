// **********************************************************************
// This file was generated by a TAF parser!
// TAF version 2.1.4.2 by WSRD Tencent.
// Generated from `/usr/local/resin_system.mqq.com/webapps/communication/taf/upload/bredzhang/reportLog.jce'
// **********************************************************************

#ifndef __REPORTLOG_H_
#define __REPORTLOG_H_

#include <map>
#include <string>
#include <vector>
#include "jce/Jce.h"
#include "pdu_header.h"
using namespace std;


struct pdu_protocol_header;

namespace cannon
{
    struct ReportInfo_Log : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "cannon.ReportInfo_Log";
        }
        static string MD5()
        {
            return "33ea96264e084159f013ac6dc7e403dc";
        }
        ReportInfo_Log()
        :time(0),uin(0),loglevel(0),hint1(0),hint2(0)
        {
        }
        void resetDefautlt()
        {
            time = 0;
            uin = 0;
            loglevel = 0;
            hint1 = 0;
            hint2 = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(time, 1);
            _os.write(uin, 2);
            _os.write(loglevel, 3);
            _os.write(hint1, 4);
            _os.write(hint2, 5);
            _os.write(log_detail, 6);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(time, 1, true);
            _is.read(uin, 2, true);
            _is.read(loglevel, 3, true);
            _is.read(hint1, 4, true);
            _is.read(hint2, 5, true);
            _is.read(log_detail, 6, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(time,"time");
            _ds.display(uin,"uin");
            _ds.display(loglevel,"loglevel");
            _ds.display(hint1,"hint1");
            _ds.display(hint2,"hint2");
            _ds.display(log_detail,"log_detail");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(time, true);
            _ds.displaySimple(uin, true);
            _ds.displaySimple(loglevel, true);
            _ds.displaySimple(hint1, true);
            _ds.displaySimple(hint2, true);
            _ds.displaySimple(log_detail, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len,pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        taf::Int64 time;
        taf::Int32 uin;
        taf::Char loglevel;
        taf::Int32 hint1;
        taf::Int32 hint2;
        vector<taf::Char> log_detail;
    };
    inline bool operator==(const ReportInfo_Log&l, const ReportInfo_Log&r)
    {
        return l.time == r.time && l.uin == r.uin && l.loglevel == r.loglevel && l.hint1 == r.hint1 && l.hint2 == r.hint2 && l.log_detail == r.log_detail;
    }
    inline bool operator!=(const ReportInfo_Log&l, const ReportInfo_Log&r)
    {
        return !(l == r);
    }
    int struct_ReportInfo_Log_pack(ReportInfo_Log * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_ReportInfo_Log_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, ReportInfo_Log * pst_struct, pdu_protocol_header * pdu_header);
    int struct_ReportInfo_Log_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, ReportInfo_Log * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct ReportInfo : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "cannon.ReportInfo";
        }
        static string MD5()
        {
            return "ad9724b3dafb6db43beb2ec500538540";
        }
        ReportInfo()
        :qua(""),plat(0),version(0),size(0)
        {
        }
        void resetDefautlt()
        {
            qua = "";
            plat = 0;
            version = 0;
            size = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(qua, 0);
            _os.write(plat, 1);
            _os.write(version, 2);
            _os.write(size, 3);
            _os.write(loglist, 4);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(qua, 0, true);
            _is.read(plat, 1, true);
            _is.read(version, 2, true);
            _is.read(size, 3, true);
            _is.read(loglist, 4, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(qua,"qua");
            _ds.display(plat,"plat");
            _ds.display(version,"version");
            _ds.display(size,"size");
            _ds.display(loglist,"loglist");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(qua, true);
            _ds.displaySimple(plat, true);
            _ds.displaySimple(version, true);
            _ds.displaySimple(size, true);
            _ds.displaySimple(loglist, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len,pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        std::string qua;
        taf::Char plat;
        taf::Short version;
        taf::Int32 size;
        vector<cannon::ReportInfo_Log> loglist;
    };
    inline bool operator==(const ReportInfo&l, const ReportInfo&r)
    {
        return l.qua == r.qua && l.plat == r.plat && l.version == r.version && l.size == r.size && l.loglist == r.loglist;
    }
    inline bool operator!=(const ReportInfo&l, const ReportInfo&r)
    {
        return !(l == r);
    }
    int struct_ReportInfo_pack(ReportInfo * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_ReportInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, ReportInfo * pst_struct, pdu_protocol_header * pdu_header);
    int struct_ReportInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, ReportInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct LogControlReq : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "cannon.LogControlReq";
        }
        static string MD5()
        {
            return "311b8c25eb3f259c7a0131aff8b30cf7";
        }
        LogControlReq()
        :time(0),loglevel(0),version(0),lasttime(0)
        {
        }
        void resetDefautlt()
        {
            time = 0;
            loglevel = 0;
            version = 0;
            lasttime = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(time, 0);
            _os.write(loglevel, 1);
            _os.write(version, 2);
            _os.write(lasttime, 3);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(time, 0, true);
            _is.read(loglevel, 1, true);
            _is.read(version, 2, true);
            _is.read(lasttime, 3, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(time,"time");
            _ds.display(loglevel,"loglevel");
            _ds.display(version,"version");
            _ds.display(lasttime,"lasttime");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(time, true);
            _ds.displaySimple(loglevel, true);
            _ds.displaySimple(version, true);
            _ds.displaySimple(lasttime, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len,pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        taf::Int32 time;
        taf::Char loglevel;
        taf::Short version;
        taf::Int32 lasttime;
    };
    inline bool operator==(const LogControlReq&l, const LogControlReq&r)
    {
        return l.time == r.time && l.loglevel == r.loglevel && l.version == r.version && l.lasttime == r.lasttime;
    }
    inline bool operator!=(const LogControlReq&l, const LogControlReq&r)
    {
        return !(l == r);
    }
    int struct_LogControlReq_pack(LogControlReq * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_LogControlReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, LogControlReq * pst_struct, pdu_protocol_header * pdu_header);
    int struct_LogControlReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, LogControlReq * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct LogUploadReq : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "cannon.LogUploadReq";
        }
        static string MD5()
        {
            return "b2f46e2910c8640d7dcdb4833f48903c";
        }
        LogUploadReq()
        :time(0),priority(0),loglevel(0),starttime(0),endtime(0),report_ip(0),report_port(0)
        {
        }
        void resetDefautlt()
        {
            time = 0;
            priority = 0;
            loglevel = 0;
            starttime = 0;
            endtime = 0;
            report_ip = 0;
            report_port = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(time, 0);
            _os.write(priority, 1);
            _os.write(loglevel, 2);
            _os.write(starttime, 3);
            _os.write(endtime, 4);
            _os.write(report_ip, 5);
            _os.write(report_port, 6);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(time, 0, true);
            _is.read(priority, 1, true);
            _is.read(loglevel, 2, true);
            _is.read(starttime, 3, true);
            _is.read(endtime, 4, true);
            _is.read(report_ip, 5, true);
            _is.read(report_port, 6, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(time,"time");
            _ds.display(priority,"priority");
            _ds.display(loglevel,"loglevel");
            _ds.display(starttime,"starttime");
            _ds.display(endtime,"endtime");
            _ds.display(report_ip,"report_ip");
            _ds.display(report_port,"report_port");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(time, true);
            _ds.displaySimple(priority, true);
            _ds.displaySimple(loglevel, true);
            _ds.displaySimple(starttime, true);
            _ds.displaySimple(endtime, true);
            _ds.displaySimple(report_ip, true);
            _ds.displaySimple(report_port, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len,pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        taf::Int32 time;
        taf::Char priority;
        taf::Char loglevel;
        taf::Int32 starttime;
        taf::Int32 endtime;
        taf::Int32 report_ip;
        taf::Short report_port;
    };
    inline bool operator==(const LogUploadReq&l, const LogUploadReq&r)
    {
        return l.time == r.time && l.priority == r.priority && l.loglevel == r.loglevel && l.starttime == r.starttime && l.endtime == r.endtime && l.report_ip == r.report_ip && l.report_port == r.report_port;
    }
    inline bool operator!=(const LogUploadReq&l, const LogUploadReq&r)
    {
        return !(l == r);
    }
    int struct_LogUploadReq_pack(LogUploadReq * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_LogUploadReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, LogUploadReq * pst_struct, pdu_protocol_header * pdu_header);
    int struct_LogUploadReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, LogUploadReq * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);


}



#endif
