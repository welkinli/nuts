// **********************************************************************
// This file was generated by a TAF parser!
// TAF version 3.0.0.20 by WSRD Tencent.
// Generated from `/usr/local/resin_system.mqq.com/webapps/communication/taf/upload/zahirpeng/qmf_service_define.jce'
// **********************************************************************

#ifndef __QMF_SERVICE_DEFINE_H_
#define __QMF_SERVICE_DEFINE_H_

#include <map>
#include <string>
#include <vector>
#include "jce/Jce.h"
#include "pdu_header.h"
using namespace std;


struct pdu_protocol_header;

namespace QMF_SERVICE
{
    struct WnsCmdLoginReq : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "QMF_SERVICE.WnsCmdLoginReq";
        }
        static string MD5()
        {
            return "28df20ad527bf2248a955955f77988bb";
        }
        WnsCmdLoginReq()
        :flag(0),sUID("")
        {
        }
        void resetDefautlt()
        {
            flag = 0;
            sUID = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(UID, 0);
            _os.write(devicetoken, 1);
            _os.write(flag, 2);
            _os.write(sUID, 3);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(UID, 0, false);
            _is.read(devicetoken, 1, false);
            _is.read(flag, 2, false);
            _is.read(sUID, 3, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(UID,"UID");
            _ds.display(devicetoken,"devicetoken");
            _ds.display(flag,"flag");
            _ds.display(sUID,"sUID");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(UID, true);
            _ds.displaySimple(devicetoken, true);
            _ds.displaySimple(flag, true);
            _ds.displaySimple(sUID, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        vector<taf::Char> UID;
        vector<taf::Char> devicetoken;
        taf::Int32 flag;
        std::string sUID;
    };
    inline bool operator==(const WnsCmdLoginReq&l, const WnsCmdLoginReq&r)
    {
        return l.UID == r.UID && l.devicetoken == r.devicetoken && l.flag == r.flag && l.sUID == r.sUID;
    }
    inline bool operator!=(const WnsCmdLoginReq&l, const WnsCmdLoginReq&r)
    {
        return !(l == r);
    }
    int struct_WnsCmdLoginReq_pack(WnsCmdLoginReq * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_WnsCmdLoginReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdLoginReq * pst_struct, pdu_protocol_header * pdu_header);
    int struct_WnsCmdLoginReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdLoginReq * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct WnsCmdLoginRsp : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "QMF_SERVICE.WnsCmdLoginRsp";
        }
        static string MD5()
        {
            return "0625248b3996871eee839e01be1ddf03";
        }
        WnsCmdLoginRsp()
        :sUID("")
        {
        }
        void resetDefautlt()
        {
            sUID = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(GTKEY_B2, 0);
            _os.write(B2, 1);
            _os.write(UID, 2);
            _os.write(sUID, 3);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(GTKEY_B2, 0, false);
            _is.read(B2, 1, false);
            _is.read(UID, 2, false);
            _is.read(sUID, 3, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(GTKEY_B2,"GTKEY_B2");
            _ds.display(B2,"B2");
            _ds.display(UID,"UID");
            _ds.display(sUID,"sUID");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(GTKEY_B2, true);
            _ds.displaySimple(B2, true);
            _ds.displaySimple(UID, true);
            _ds.displaySimple(sUID, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        vector<taf::Char> GTKEY_B2;
        vector<taf::Char> B2;
        vector<taf::Char> UID;
        std::string sUID;
    };
    inline bool operator==(const WnsCmdLoginRsp&l, const WnsCmdLoginRsp&r)
    {
        return l.GTKEY_B2 == r.GTKEY_B2 && l.B2 == r.B2 && l.UID == r.UID && l.sUID == r.sUID;
    }
    inline bool operator!=(const WnsCmdLoginRsp&l, const WnsCmdLoginRsp&r)
    {
        return !(l == r);
    }
    int struct_WnsCmdLoginRsp_pack(WnsCmdLoginRsp * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_WnsCmdLoginRsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdLoginRsp * pst_struct, pdu_protocol_header * pdu_header);
    int struct_WnsCmdLoginRsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdLoginRsp * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct SdkConnMgrInfo : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "QMF_SERVICE.SdkConnMgrInfo";
        }
        static string MD5()
        {
            return "7789c630a0c043066af5853376d738e4";
        }
        SdkConnMgrInfo()
        :ip_principle(0),apn_type(0),is_bgd(0)
        {
        }
        void resetDefautlt()
        {
            ip_principle = 0;
            apn_type = 0;
            is_bgd = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(ip_principle, 0);
            _os.write(apn_type, 1);
            _os.write(is_bgd, 2);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ip_principle, 0, false);
            _is.read(apn_type, 1, false);
            _is.read(is_bgd, 2, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(ip_principle,"ip_principle");
            _ds.display(apn_type,"apn_type");
            _ds.display(is_bgd,"is_bgd");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(ip_principle, true);
            _ds.displaySimple(apn_type, true);
            _ds.displaySimple(is_bgd, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        taf::Char ip_principle;
        taf::Char apn_type;
        taf::Char is_bgd;
    };
    inline bool operator==(const SdkConnMgrInfo&l, const SdkConnMgrInfo&r)
    {
        return l.ip_principle == r.ip_principle && l.apn_type == r.apn_type && l.is_bgd == r.is_bgd;
    }
    inline bool operator!=(const SdkConnMgrInfo&l, const SdkConnMgrInfo&r)
    {
        return !(l == r);
    }
    int struct_SdkConnMgrInfo_pack(SdkConnMgrInfo * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_SdkConnMgrInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, SdkConnMgrInfo * pst_struct, pdu_protocol_header * pdu_header);
    int struct_SdkConnMgrInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, SdkConnMgrInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct WnsCmdHeartBeat : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "QMF_SERVICE.WnsCmdHeartBeat";
        }
        static string MD5()
        {
            return "cda90e13c2fb55b3380a854c9385f267";
        }
        WnsCmdHeartBeat()
        :ptime(0),sUID(""),is_fake_hb(0)
        {
        }
        void resetDefautlt()
        {
            ptime = 0;
            sUID = "";
            is_fake_hb = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(UID, 0);
            _os.write(ptime, 1);
            _os.write(mgr_info, 2);
            _os.write(sUID, 3);
            _os.write(is_fake_hb, 4);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(UID, 0, false);
            _is.read(ptime, 1, false);
            _is.read(mgr_info, 2, false);
            _is.read(sUID, 3, false);
            _is.read(is_fake_hb, 4, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(UID,"UID");
            _ds.display(ptime,"ptime");
            _ds.display(mgr_info,"mgr_info");
            _ds.display(sUID,"sUID");
            _ds.display(is_fake_hb,"is_fake_hb");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(UID, true);
            _ds.displaySimple(ptime, true);
            _ds.displaySimple(mgr_info, true);
            _ds.displaySimple(sUID, true);
            _ds.displaySimple(is_fake_hb, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        vector<taf::Char> UID;
        taf::Int32 ptime;
        QMF_SERVICE::SdkConnMgrInfo mgr_info;
        std::string sUID;
        taf::Char is_fake_hb;
    };
    inline bool operator==(const WnsCmdHeartBeat&l, const WnsCmdHeartBeat&r)
    {
        return l.UID == r.UID && l.ptime == r.ptime && l.mgr_info == r.mgr_info && l.sUID == r.sUID && l.is_fake_hb == r.is_fake_hb;
    }
    inline bool operator!=(const WnsCmdHeartBeat&l, const WnsCmdHeartBeat&r)
    {
        return !(l == r);
    }
    int struct_WnsCmdHeartBeat_pack(WnsCmdHeartBeat * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_WnsCmdHeartBeat_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdHeartBeat * pst_struct, pdu_protocol_header * pdu_header);
    int struct_WnsCmdHeartBeat_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdHeartBeat * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct WnsCmdLoginOff : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "QMF_SERVICE.WnsCmdLoginOff";
        }
        static string MD5()
        {
            return "5ede9b8323c9a5771a0fa7b5d687808a";
        }
        WnsCmdLoginOff()
        :sUID("")
        {
        }
        void resetDefautlt()
        {
            sUID = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(UID, 0);
            _os.write(sUID, 1);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(UID, 0, false);
            _is.read(sUID, 1, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(UID,"UID");
            _ds.display(sUID,"sUID");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(UID, true);
            _ds.displaySimple(sUID, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        vector<taf::Char> UID;
        std::string sUID;
    };
    inline bool operator==(const WnsCmdLoginOff&l, const WnsCmdLoginOff&r)
    {
        return l.UID == r.UID && l.sUID == r.sUID;
    }
    inline bool operator!=(const WnsCmdLoginOff&l, const WnsCmdLoginOff&r)
    {
        return !(l == r);
    }
    int struct_WnsCmdLoginOff_pack(WnsCmdLoginOff * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_WnsCmdLoginOff_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdLoginOff * pst_struct, pdu_protocol_header * pdu_header);
    int struct_WnsCmdLoginOff_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdLoginOff * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct WnsIpInfo : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "QMF_SERVICE.WnsIpInfo";
        }
        static string MD5()
        {
            return "224fd36cb77e941788d7c2a8c6f3a783";
        }
        WnsIpInfo()
        :ip(0),port(0),apn(0),remark("")
        {
        }
        void resetDefautlt()
        {
            ip = 0;
            port = 0;
            apn = 0;
            remark = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(ip, 0);
            _os.write(port, 1);
            _os.write(apn, 2);
            _os.write(remark, 3);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ip, 0, false);
            _is.read(port, 1, false);
            _is.read(apn, 2, false);
            _is.read(remark, 3, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(ip,"ip");
            _ds.display(port,"port");
            _ds.display(apn,"apn");
            _ds.display(remark,"remark");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(ip, true);
            _ds.displaySimple(port, true);
            _ds.displaySimple(apn, true);
            _ds.displaySimple(remark, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        taf::Int32 ip;
        taf::Short port;
        taf::Char apn;
        std::string remark;
    };
    inline bool operator==(const WnsIpInfo&l, const WnsIpInfo&r)
    {
        return l.ip == r.ip && l.port == r.port && l.apn == r.apn && l.remark == r.remark;
    }
    inline bool operator!=(const WnsIpInfo&l, const WnsIpInfo&r)
    {
        return !(l == r);
    }
    int struct_WnsIpInfo_pack(WnsIpInfo * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_WnsIpInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsIpInfo * pst_struct, pdu_protocol_header * pdu_header);
    int struct_WnsIpInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsIpInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct WnsCmdHandShakeReq : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "QMF_SERVICE.WnsCmdHandShakeReq";
        }
        static string MD5()
        {
            return "38c08a0b984d96d5b309e92f5b9215db";
        }
        WnsCmdHandShakeReq()
        :type(0)
        {
        }
        void resetDefautlt()
        {
            type = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(type, 0);
            _os.write(mgr_info, 1);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(type, 0, true);
            _is.read(mgr_info, 1, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(type,"type");
            _ds.display(mgr_info,"mgr_info");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(type, true);
            _ds.displaySimple(mgr_info, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        taf::Int32 type;
        QMF_SERVICE::SdkConnMgrInfo mgr_info;
    };
    inline bool operator==(const WnsCmdHandShakeReq&l, const WnsCmdHandShakeReq&r)
    {
        return l.type == r.type && l.mgr_info == r.mgr_info;
    }
    inline bool operator!=(const WnsCmdHandShakeReq&l, const WnsCmdHandShakeReq&r)
    {
        return !(l == r);
    }
    int struct_WnsCmdHandShakeReq_pack(WnsCmdHandShakeReq * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_WnsCmdHandShakeReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdHandShakeReq * pst_struct, pdu_protocol_header * pdu_header);
    int struct_WnsCmdHandShakeReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdHandShakeReq * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct WnsCmdHandShakeRsp : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "QMF_SERVICE.WnsCmdHandShakeRsp";
        }
        static string MD5()
        {
            return "c3ef07434c1e4c274f5e1a83e085d980";
        }
        WnsCmdHandShakeRsp()
        :type(0),uprinciple(0),clientinfo("")
        {
        }
        void resetDefautlt()
        {
            type = 0;
            uprinciple = 0;
            clientinfo = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(type, 0);
            _os.write(redirect, 1);
            _os.write(uprinciple, 2);
            _os.write(clientinfo, 3);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(type, 0, true);
            _is.read(redirect, 1, false);
            _is.read(uprinciple, 2, false);
            _is.read(clientinfo, 3, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(type,"type");
            _ds.display(redirect,"redirect");
            _ds.display(uprinciple,"uprinciple");
            _ds.display(clientinfo,"clientinfo");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(type, true);
            _ds.displaySimple(redirect, true);
            _ds.displaySimple(uprinciple, true);
            _ds.displaySimple(clientinfo, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        taf::Int32 type;
        vector<QMF_SERVICE::WnsIpInfo> redirect;
        taf::Char uprinciple;
        std::string clientinfo;
    };
    inline bool operator==(const WnsCmdHandShakeRsp&l, const WnsCmdHandShakeRsp&r)
    {
        return l.type == r.type && l.redirect == r.redirect && l.uprinciple == r.uprinciple && l.clientinfo == r.clientinfo;
    }
    inline bool operator!=(const WnsCmdHandShakeRsp&l, const WnsCmdHandShakeRsp&r)
    {
        return !(l == r);
    }
    int struct_WnsCmdHandShakeRsp_pack(WnsCmdHandShakeRsp * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_WnsCmdHandShakeRsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdHandShakeRsp * pst_struct, pdu_protocol_header * pdu_header);
    int struct_WnsCmdHandShakeRsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdHandShakeRsp * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct WnsCmdServerListRsp : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "QMF_SERVICE.WnsCmdServerListRsp";
        }
        static string MD5()
        {
            return "7e08fcf49c728cf5b89ff531c09fd5b1";
        }
        WnsCmdServerListRsp()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(optimumip, 0);
            _os.write(speed4test, 1);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(optimumip, 0, false);
            _is.read(speed4test, 1, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(optimumip,"optimumip");
            _ds.display(speed4test,"speed4test");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(optimumip, true);
            _ds.displaySimple(speed4test, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        vector<QMF_SERVICE::WnsIpInfo> optimumip;
        vector<QMF_SERVICE::WnsIpInfo> speed4test;
    };
    inline bool operator==(const WnsCmdServerListRsp&l, const WnsCmdServerListRsp&r)
    {
        return l.optimumip == r.optimumip && l.speed4test == r.speed4test;
    }
    inline bool operator!=(const WnsCmdServerListRsp&l, const WnsCmdServerListRsp&r)
    {
        return !(l == r);
    }
    int struct_WnsCmdServerListRsp_pack(WnsCmdServerListRsp * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_WnsCmdServerListRsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdServerListRsp * pst_struct, pdu_protocol_header * pdu_header);
    int struct_WnsCmdServerListRsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdServerListRsp * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct WnsSpeedLatencyInfo : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "QMF_SERVICE.WnsSpeedLatencyInfo";
        }
        static string MD5()
        {
            return "d74b1b0f5c206e5a4fa86be60d297f43";
        }
        WnsSpeedLatencyInfo()
        :conect(0),upstream(0),downstram(0),accepy(0)
        {
        }
        void resetDefautlt()
        {
            conect = 0;
            upstream = 0;
            downstram = 0;
            accepy = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(conect, 0);
            _os.write(upstream, 1);
            _os.write(downstram, 2);
            _os.write(accepy, 3);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(conect, 0, true);
            _is.read(upstream, 1, true);
            _is.read(downstram, 2, true);
            _is.read(accepy, 3, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(conect,"conect");
            _ds.display(upstream,"upstream");
            _ds.display(downstram,"downstram");
            _ds.display(accepy,"accepy");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(conect, true);
            _ds.displaySimple(upstream, true);
            _ds.displaySimple(downstram, true);
            _ds.displaySimple(accepy, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        taf::Int64 conect;
        taf::Int64 upstream;
        taf::Int64 downstram;
        taf::Int64 accepy;
    };
    inline bool operator==(const WnsSpeedLatencyInfo&l, const WnsSpeedLatencyInfo&r)
    {
        return l.conect == r.conect && l.upstream == r.upstream && l.downstram == r.downstram && l.accepy == r.accepy;
    }
    inline bool operator!=(const WnsSpeedLatencyInfo&l, const WnsSpeedLatencyInfo&r)
    {
        return !(l == r);
    }
    int struct_WnsSpeedLatencyInfo_pack(WnsSpeedLatencyInfo * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_WnsSpeedLatencyInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsSpeedLatencyInfo * pst_struct, pdu_protocol_header * pdu_header);
    int struct_WnsSpeedLatencyInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsSpeedLatencyInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct WnsReportTestIpInfo : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "QMF_SERVICE.WnsReportTestIpInfo";
        }
        static string MD5()
        {
            return "b194320088765d224cd07664abbcdbfc";
        }
        WnsReportTestIpInfo()
        :retCmd(0),ip(0),domain(""),port(0),signal(""),apn(0),lbs("")
        {
        }
        void resetDefautlt()
        {
            retCmd = 0;
            ip = 0;
            domain = "";
            port = 0;
            signal = "";
            apn = 0;
            lbs = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(retCmd, 0);
            _os.write(ip, 1);
            _os.write(domain, 2);
            _os.write(port, 3);
            _os.write(latencyInfo, 4);
            _os.write(signal, 5);
            _os.write(apn, 6);
            _os.write(lbs, 7);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(retCmd, 0, true);
            _is.read(ip, 1, false);
            _is.read(domain, 2, false);
            _is.read(port, 3, false);
            _is.read(latencyInfo, 4, true);
            _is.read(signal, 5, false);
            _is.read(apn, 6, true);
            _is.read(lbs, 7, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(retCmd,"retCmd");
            _ds.display(ip,"ip");
            _ds.display(domain,"domain");
            _ds.display(port,"port");
            _ds.display(latencyInfo,"latencyInfo");
            _ds.display(signal,"signal");
            _ds.display(apn,"apn");
            _ds.display(lbs,"lbs");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(retCmd, true);
            _ds.displaySimple(ip, true);
            _ds.displaySimple(domain, true);
            _ds.displaySimple(port, true);
            _ds.displaySimple(latencyInfo, true);
            _ds.displaySimple(signal, true);
            _ds.displaySimple(apn, true);
            _ds.displaySimple(lbs, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        taf::Short retCmd;
        taf::Int32 ip;
        std::string domain;
        taf::Short port;
        QMF_SERVICE::WnsSpeedLatencyInfo latencyInfo;
        std::string signal;
        taf::Char apn;
        std::string lbs;
    };
    inline bool operator==(const WnsReportTestIpInfo&l, const WnsReportTestIpInfo&r)
    {
        return l.retCmd == r.retCmd && l.ip == r.ip && l.domain == r.domain && l.port == r.port && l.latencyInfo == r.latencyInfo && l.signal == r.signal && l.apn == r.apn && l.lbs == r.lbs;
    }
    inline bool operator!=(const WnsReportTestIpInfo&l, const WnsReportTestIpInfo&r)
    {
        return !(l == r);
    }
    int struct_WnsReportTestIpInfo_pack(WnsReportTestIpInfo * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_WnsReportTestIpInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsReportTestIpInfo * pst_struct, pdu_protocol_header * pdu_header);
    int struct_WnsReportTestIpInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsReportTestIpInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct WnsCmdSpeed4TestReq : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "QMF_SERVICE.WnsCmdSpeed4TestReq";
        }
        static string MD5()
        {
            return "3b93efb71d399aa41ce889bbeaa378ba";
        }
        WnsCmdSpeed4TestReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(speed4test, 0);
            _os.write(test_ip_info, 1);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(speed4test, 0, false);
            _is.read(test_ip_info, 1, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(speed4test,"speed4test");
            _ds.display(test_ip_info,"test_ip_info");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(speed4test, true);
            _ds.displaySimple(test_ip_info, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        vector<QMF_SERVICE::WnsIpInfo> speed4test;
        vector<QMF_SERVICE::WnsReportTestIpInfo> test_ip_info;
    };
    inline bool operator==(const WnsCmdSpeed4TestReq&l, const WnsCmdSpeed4TestReq&r)
    {
        return l.speed4test == r.speed4test && l.test_ip_info == r.test_ip_info;
    }
    inline bool operator!=(const WnsCmdSpeed4TestReq&l, const WnsCmdSpeed4TestReq&r)
    {
        return !(l == r);
    }
    int struct_WnsCmdSpeed4TestReq_pack(WnsCmdSpeed4TestReq * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_WnsCmdSpeed4TestReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdSpeed4TestReq * pst_struct, pdu_protocol_header * pdu_header);
    int struct_WnsCmdSpeed4TestReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdSpeed4TestReq * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct WnsCmdSettingReq : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "QMF_SERVICE.WnsCmdSettingReq";
        }
        static string MD5()
        {
            return "05511bece4a2b65e1361cf6867461c97";
        }
        WnsCmdSettingReq()
        :type(0)
        {
        }
        void resetDefautlt()
        {
            type = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(type, 0);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(type, 0, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(type,"type");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(type, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        taf::Int32 type;
    };
    inline bool operator==(const WnsCmdSettingReq&l, const WnsCmdSettingReq&r)
    {
        return l.type == r.type;
    }
    inline bool operator!=(const WnsCmdSettingReq&l, const WnsCmdSettingReq&r)
    {
        return !(l == r);
    }
    int struct_WnsCmdSettingReq_pack(WnsCmdSettingReq * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_WnsCmdSettingReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdSettingReq * pst_struct, pdu_protocol_header * pdu_header);
    int struct_WnsCmdSettingReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdSettingReq * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct WnsCmdSettingRsp : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "QMF_SERVICE.WnsCmdSettingRsp";
        }
        static string MD5()
        {
            return "26159cf77dcb9fe1c64b57dae580ccae";
        }
        WnsCmdSettingRsp()
        :type(0),setting("")
        {
        }
        void resetDefautlt()
        {
            type = 0;
            setting = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(type, 0);
            _os.write(setting, 1);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(type, 0, true);
            _is.read(setting, 1, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(type,"type");
            _ds.display(setting,"setting");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(type, true);
            _ds.displaySimple(setting, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        taf::Int32 type;
        std::string setting;
    };
    inline bool operator==(const WnsCmdSettingRsp&l, const WnsCmdSettingRsp&r)
    {
        return l.type == r.type && l.setting == r.setting;
    }
    inline bool operator!=(const WnsCmdSettingRsp&l, const WnsCmdSettingRsp&r)
    {
        return !(l == r);
    }
    int struct_WnsCmdSettingRsp_pack(WnsCmdSettingRsp * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_WnsCmdSettingRsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdSettingRsp * pst_struct, pdu_protocol_header * pdu_header);
    int struct_WnsCmdSettingRsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdSettingRsp * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct WnsCmdPushRegisterReq : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "QMF_SERVICE.WnsCmdPushRegisterReq";
        }
        static string MD5()
        {
            return "8b7ab0a0ccf730b20868c93417158f6d";
        }
        WnsCmdPushRegisterReq()
        :onoff(true),dnd(true),dnd_begin(0),dnd_end(0),sUID(""),onoff_flag(1),Wp8Uri("")
        {
        }
        void resetDefautlt()
        {
            onoff = true;
            dnd = true;
            dnd_begin = 0;
            dnd_end = 0;
            sUID = "";
            onoff_flag = 1;
            Wp8Uri = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(UID, 0);
            _os.write(devicetoken, 1);
            _os.write(onoff, 2);
            _os.write(dnd, 3);
            _os.write(dnd_begin, 4);
            _os.write(dnd_end, 5);
            _os.write(sUID, 6);
            _os.write(onoff_flag, 7);
            _os.write(Wp8Uri, 8);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(UID, 0, false);
            _is.read(devicetoken, 1, false);
            _is.read(onoff, 2, false);
            _is.read(dnd, 3, false);
            _is.read(dnd_begin, 4, false);
            _is.read(dnd_end, 5, false);
            _is.read(sUID, 6, false);
            _is.read(onoff_flag, 7, false);
            _is.read(Wp8Uri, 8, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(UID,"UID");
            _ds.display(devicetoken,"devicetoken");
            _ds.display(onoff,"onoff");
            _ds.display(dnd,"dnd");
            _ds.display(dnd_begin,"dnd_begin");
            _ds.display(dnd_end,"dnd_end");
            _ds.display(sUID,"sUID");
            _ds.display(onoff_flag,"onoff_flag");
            _ds.display(Wp8Uri,"Wp8Uri");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(UID, true);
            _ds.displaySimple(devicetoken, true);
            _ds.displaySimple(onoff, true);
            _ds.displaySimple(dnd, true);
            _ds.displaySimple(dnd_begin, true);
            _ds.displaySimple(dnd_end, true);
            _ds.displaySimple(sUID, true);
            _ds.displaySimple(onoff_flag, true);
            _ds.displaySimple(Wp8Uri, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        vector<taf::Char> UID;
        vector<taf::Char> devicetoken;
        taf::Bool onoff;
        taf::Bool dnd;
        taf::Short dnd_begin;
        taf::Short dnd_end;
        std::string sUID;
        taf::Int32 onoff_flag;
        std::string Wp8Uri;
    };
    inline bool operator==(const WnsCmdPushRegisterReq&l, const WnsCmdPushRegisterReq&r)
    {
        return l.UID == r.UID && l.devicetoken == r.devicetoken && l.onoff == r.onoff && l.dnd == r.dnd && l.dnd_begin == r.dnd_begin && l.dnd_end == r.dnd_end && l.sUID == r.sUID && l.onoff_flag == r.onoff_flag && l.Wp8Uri == r.Wp8Uri;
    }
    inline bool operator!=(const WnsCmdPushRegisterReq&l, const WnsCmdPushRegisterReq&r)
    {
        return !(l == r);
    }
    int struct_WnsCmdPushRegisterReq_pack(WnsCmdPushRegisterReq * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_WnsCmdPushRegisterReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdPushRegisterReq * pst_struct, pdu_protocol_header * pdu_header);
    int struct_WnsCmdPushRegisterReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdPushRegisterReq * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct WnsCmdPushRegisterRsp : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "QMF_SERVICE.WnsCmdPushRegisterRsp";
        }
        static string MD5()
        {
            return "5ede9b8323c9a5771a0fa7b5d687808a";
        }
        WnsCmdPushRegisterRsp()
        :sUID("")
        {
        }
        void resetDefautlt()
        {
            sUID = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(UID, 1);
            _os.write(sUID, 2);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(UID, 1, false);
            _is.read(sUID, 2, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(UID,"UID");
            _ds.display(sUID,"sUID");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(UID, true);
            _ds.displaySimple(sUID, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        vector<taf::Char> UID;
        std::string sUID;
    };
    inline bool operator==(const WnsCmdPushRegisterRsp&l, const WnsCmdPushRegisterRsp&r)
    {
        return l.UID == r.UID && l.sUID == r.sUID;
    }
    inline bool operator!=(const WnsCmdPushRegisterRsp&l, const WnsCmdPushRegisterRsp&r)
    {
        return !(l == r);
    }
    int struct_WnsCmdPushRegisterRsp_pack(WnsCmdPushRegisterRsp * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_WnsCmdPushRegisterRsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdPushRegisterRsp * pst_struct, pdu_protocol_header * pdu_header);
    int struct_WnsCmdPushRegisterRsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdPushRegisterRsp * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct WnsSpeedTestIpInfo : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "QMF_SERVICE.WnsSpeedTestIpInfo";
        }
        static string MD5()
        {
            return "1d503893c6c857acc1e7686fee6de092";
        }
        WnsSpeedTestIpInfo()
        :ip(0),domain(""),port(0)
        {
        }
        void resetDefautlt()
        {
            ip = 0;
            domain = "";
            port = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(ip, 0);
            _os.write(domain, 1);
            _os.write(port, 2);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(ip, 0, false);
            _is.read(domain, 1, false);
            _is.read(port, 2, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(ip,"ip");
            _ds.display(domain,"domain");
            _ds.display(port,"port");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(ip, true);
            _ds.displaySimple(domain, true);
            _ds.displaySimple(port, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        taf::Int32 ip;
        std::string domain;
        taf::Short port;
    };
    inline bool operator==(const WnsSpeedTestIpInfo&l, const WnsSpeedTestIpInfo&r)
    {
        return l.ip == r.ip && l.domain == r.domain && l.port == r.port;
    }
    inline bool operator!=(const WnsSpeedTestIpInfo&l, const WnsSpeedTestIpInfo&r)
    {
        return !(l == r);
    }
    int struct_WnsSpeedTestIpInfo_pack(WnsSpeedTestIpInfo * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_WnsSpeedTestIpInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsSpeedTestIpInfo * pst_struct, pdu_protocol_header * pdu_header);
    int struct_WnsSpeedTestIpInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsSpeedTestIpInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct WnsCmdGetTestSpeedIpListReq : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "QMF_SERVICE.WnsCmdGetTestSpeedIpListReq";
        }
        static string MD5()
        {
            return "42dd6e1c65c02b2d9d654de5efd33f33";
        }
        WnsCmdGetTestSpeedIpListReq()
        :apn(0)
        {
        }
        void resetDefautlt()
        {
            apn = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(apn, 0);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(apn, 0, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(apn,"apn");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(apn, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        taf::Char apn;
    };
    inline bool operator==(const WnsCmdGetTestSpeedIpListReq&l, const WnsCmdGetTestSpeedIpListReq&r)
    {
        return l.apn == r.apn;
    }
    inline bool operator!=(const WnsCmdGetTestSpeedIpListReq&l, const WnsCmdGetTestSpeedIpListReq&r)
    {
        return !(l == r);
    }
    int struct_WnsCmdGetTestSpeedIpListReq_pack(WnsCmdGetTestSpeedIpListReq * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_WnsCmdGetTestSpeedIpListReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdGetTestSpeedIpListReq * pst_struct, pdu_protocol_header * pdu_header);
    int struct_WnsCmdGetTestSpeedIpListReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdGetTestSpeedIpListReq * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct WnsCmdGetTestSpeedIpListRsp : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "QMF_SERVICE.WnsCmdGetTestSpeedIpListRsp";
        }
        static string MD5()
        {
            return "ea8c2f629fdf29f09e54c18698cdf640";
        }
        WnsCmdGetTestSpeedIpListRsp()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(test_ip_info, 0);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(test_ip_info, 0, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(test_ip_info,"test_ip_info");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(test_ip_info, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        vector<QMF_SERVICE::WnsSpeedTestIpInfo> test_ip_info;
    };
    inline bool operator==(const WnsCmdGetTestSpeedIpListRsp&l, const WnsCmdGetTestSpeedIpListRsp&r)
    {
        return l.test_ip_info == r.test_ip_info;
    }
    inline bool operator!=(const WnsCmdGetTestSpeedIpListRsp&l, const WnsCmdGetTestSpeedIpListRsp&r)
    {
        return !(l == r);
    }
    int struct_WnsCmdGetTestSpeedIpListRsp_pack(WnsCmdGetTestSpeedIpListRsp * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_WnsCmdGetTestSpeedIpListRsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdGetTestSpeedIpListRsp * pst_struct, pdu_protocol_header * pdu_header);
    int struct_WnsCmdGetTestSpeedIpListRsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdGetTestSpeedIpListRsp * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);


}



namespace QMF_LOG
{
    struct LogInfo : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "QMF_LOG.LogInfo";
        }
        static string MD5()
        {
            return "3be14e731507f09e1c89210f1be681f7";
        }
        LogInfo()
        :time(0),uin(0),loglevel(0),hint1(0),hint2(0),log_detail("")
        {
        }
        void resetDefautlt()
        {
            time = 0;
            uin = 0;
            loglevel = 0;
            hint1 = 0;
            hint2 = 0;
            log_detail = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(time, 1);
            _os.write(uin, 2);
            _os.write(loglevel, 3);
            _os.write(hint1, 4);
            _os.write(hint2, 5);
            _os.write(log_detail, 6);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(time, 1, true);
            _is.read(uin, 2, true);
            _is.read(loglevel, 3, true);
            _is.read(hint1, 4, true);
            _is.read(hint2, 5, true);
            _is.read(log_detail, 6, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(time,"time");
            _ds.display(uin,"uin");
            _ds.display(loglevel,"loglevel");
            _ds.display(hint1,"hint1");
            _ds.display(hint2,"hint2");
            _ds.display(log_detail,"log_detail");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(time, true);
            _ds.displaySimple(uin, true);
            _ds.displaySimple(loglevel, true);
            _ds.displaySimple(hint1, true);
            _ds.displaySimple(hint2, true);
            _ds.displaySimple(log_detail, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        taf::Int64 time;
        taf::Int32 uin;
        taf::Char loglevel;
        taf::Int32 hint1;
        taf::Int32 hint2;
        std::string log_detail;
    };
    inline bool operator==(const LogInfo&l, const LogInfo&r)
    {
        return l.time == r.time && l.uin == r.uin && l.loglevel == r.loglevel && l.hint1 == r.hint1 && l.hint2 == r.hint2 && l.log_detail == r.log_detail;
    }
    inline bool operator!=(const LogInfo&l, const LogInfo&r)
    {
        return !(l == r);
    }
    int struct_LogInfo_pack(LogInfo * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_LogInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, LogInfo * pst_struct, pdu_protocol_header * pdu_header);
    int struct_LogInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, LogInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct WnsCmdReportLog : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "QMF_LOG.WnsCmdReportLog";
        }
        static string MD5()
        {
            return "e61c6a89ceb0d2fbd5e03cb09aa49c88";
        }
        WnsCmdReportLog()
        :qua(""),plat(0),version(0),size(0),sUID("")
        {
        }
        void resetDefautlt()
        {
            qua = "";
            plat = 0;
            version = 0;
            size = 0;
            sUID = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(qua, 0);
            _os.write(plat, 1);
            _os.write(version, 2);
            _os.write(size, 3);
            _os.write(loglist, 4);
            _os.write(UID, 5);
            _os.write(sUID, 6);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(qua, 0, true);
            _is.read(plat, 1, true);
            _is.read(version, 2, true);
            _is.read(size, 3, true);
            _is.read(loglist, 4, true);
            _is.read(UID, 5, false);
            _is.read(sUID, 6, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(qua,"qua");
            _ds.display(plat,"plat");
            _ds.display(version,"version");
            _ds.display(size,"size");
            _ds.display(loglist,"loglist");
            _ds.display(UID,"UID");
            _ds.display(sUID,"sUID");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(qua, true);
            _ds.displaySimple(plat, true);
            _ds.displaySimple(version, true);
            _ds.displaySimple(size, true);
            _ds.displaySimple(loglist, true);
            _ds.displaySimple(UID, true);
            _ds.displaySimple(sUID, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        std::string qua;
        taf::Char plat;
        taf::Short version;
        taf::Int32 size;
        vector<QMF_LOG::LogInfo> loglist;
        vector<taf::Char> UID;
        std::string sUID;
    };
    inline bool operator==(const WnsCmdReportLog&l, const WnsCmdReportLog&r)
    {
        return l.qua == r.qua && l.plat == r.plat && l.version == r.version && l.size == r.size && l.loglist == r.loglist && l.UID == r.UID && l.sUID == r.sUID;
    }
    inline bool operator!=(const WnsCmdReportLog&l, const WnsCmdReportLog&r)
    {
        return !(l == r);
    }
    int struct_WnsCmdReportLog_pack(WnsCmdReportLog * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_WnsCmdReportLog_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdReportLog * pst_struct, pdu_protocol_header * pdu_header);
    int struct_WnsCmdReportLog_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdReportLog * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct WnsCmdLogControlReq : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "QMF_LOG.WnsCmdLogControlReq";
        }
        static string MD5()
        {
            return "311b8c25eb3f259c7a0131aff8b30cf7";
        }
        WnsCmdLogControlReq()
        :time(0),loglevel(0),version(0),lasttime(0)
        {
        }
        void resetDefautlt()
        {
            time = 0;
            loglevel = 0;
            version = 0;
            lasttime = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(time, 0);
            _os.write(loglevel, 1);
            _os.write(version, 2);
            _os.write(lasttime, 3);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(time, 0, true);
            _is.read(loglevel, 1, true);
            _is.read(version, 2, true);
            _is.read(lasttime, 3, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(time,"time");
            _ds.display(loglevel,"loglevel");
            _ds.display(version,"version");
            _ds.display(lasttime,"lasttime");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(time, true);
            _ds.displaySimple(loglevel, true);
            _ds.displaySimple(version, true);
            _ds.displaySimple(lasttime, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        taf::Int32 time;
        taf::Char loglevel;
        taf::Short version;
        taf::Int32 lasttime;
    };
    inline bool operator==(const WnsCmdLogControlReq&l, const WnsCmdLogControlReq&r)
    {
        return l.time == r.time && l.loglevel == r.loglevel && l.version == r.version && l.lasttime == r.lasttime;
    }
    inline bool operator!=(const WnsCmdLogControlReq&l, const WnsCmdLogControlReq&r)
    {
        return !(l == r);
    }
    int struct_WnsCmdLogControlReq_pack(WnsCmdLogControlReq * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_WnsCmdLogControlReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdLogControlReq * pst_struct, pdu_protocol_header * pdu_header);
    int struct_WnsCmdLogControlReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdLogControlReq * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct WnsCmdLogControlRsp : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "QMF_LOG.WnsCmdLogControlRsp";
        }
        static string MD5()
        {
            return "feec12de7b13d3c49a37abb722ac4db4";
        }
        WnsCmdLogControlRsp()
        :time(0),status(0)
        {
        }
        void resetDefautlt()
        {
            time = 0;
            status = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(time, 0);
            _os.write(status, 1);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(time, 0, true);
            _is.read(status, 1, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(time,"time");
            _ds.display(status,"status");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(time, true);
            _ds.displaySimple(status, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        taf::Int32 time;
        taf::Int32 status;
    };
    inline bool operator==(const WnsCmdLogControlRsp&l, const WnsCmdLogControlRsp&r)
    {
        return l.time == r.time && l.status == r.status;
    }
    inline bool operator!=(const WnsCmdLogControlRsp&l, const WnsCmdLogControlRsp&r)
    {
        return !(l == r);
    }
    int struct_WnsCmdLogControlRsp_pack(WnsCmdLogControlRsp * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_WnsCmdLogControlRsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdLogControlRsp * pst_struct, pdu_protocol_header * pdu_header);
    int struct_WnsCmdLogControlRsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdLogControlRsp * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct WnsCmdLogUploadReq : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "QMF_LOG.WnsCmdLogUploadReq";
        }
        static string MD5()
        {
            return "5dff7869b3b4a6077bf7692405a2d878";
        }
        WnsCmdLogUploadReq()
        :time(0),priority(0),loglevel(0),starttime(0),endtime(0),report_ip(0),report_port(0),maxLogLines(0)
        {
        }
        void resetDefautlt()
        {
            time = 0;
            priority = 0;
            loglevel = 0;
            starttime = 0;
            endtime = 0;
            report_ip = 0;
            report_port = 0;
            maxLogLines = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(time, 0);
            _os.write(priority, 1);
            _os.write(loglevel, 2);
            _os.write(starttime, 3);
            _os.write(endtime, 4);
            _os.write(report_ip, 5);
            _os.write(report_port, 6);
            _os.write(maxLogLines, 7);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(time, 0, true);
            _is.read(priority, 1, true);
            _is.read(loglevel, 2, true);
            _is.read(starttime, 3, true);
            _is.read(endtime, 4, true);
            _is.read(report_ip, 5, true);
            _is.read(report_port, 6, true);
            _is.read(maxLogLines, 7, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(time,"time");
            _ds.display(priority,"priority");
            _ds.display(loglevel,"loglevel");
            _ds.display(starttime,"starttime");
            _ds.display(endtime,"endtime");
            _ds.display(report_ip,"report_ip");
            _ds.display(report_port,"report_port");
            _ds.display(maxLogLines,"maxLogLines");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(time, true);
            _ds.displaySimple(priority, true);
            _ds.displaySimple(loglevel, true);
            _ds.displaySimple(starttime, true);
            _ds.displaySimple(endtime, true);
            _ds.displaySimple(report_ip, true);
            _ds.displaySimple(report_port, true);
            _ds.displaySimple(maxLogLines, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        taf::Int32 time;
        taf::Char priority;
        taf::Char loglevel;
        taf::Int32 starttime;
        taf::Int32 endtime;
        taf::Int32 report_ip;
        taf::Short report_port;
        taf::Int32 maxLogLines;
    };
    inline bool operator==(const WnsCmdLogUploadReq&l, const WnsCmdLogUploadReq&r)
    {
        return l.time == r.time && l.priority == r.priority && l.loglevel == r.loglevel && l.starttime == r.starttime && l.endtime == r.endtime && l.report_ip == r.report_ip && l.report_port == r.report_port && l.maxLogLines == r.maxLogLines;
    }
    inline bool operator!=(const WnsCmdLogUploadReq&l, const WnsCmdLogUploadReq&r)
    {
        return !(l == r);
    }
    int struct_WnsCmdLogUploadReq_pack(WnsCmdLogUploadReq * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_WnsCmdLogUploadReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdLogUploadReq * pst_struct, pdu_protocol_header * pdu_header);
    int struct_WnsCmdLogUploadReq_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdLogUploadReq * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct WnsCmdLogUploadRsp : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "QMF_LOG.WnsCmdLogUploadRsp";
        }
        static string MD5()
        {
            return "feec12de7b13d3c49a37abb722ac4db4";
        }
        WnsCmdLogUploadRsp()
        :time(0),status(0)
        {
        }
        void resetDefautlt()
        {
            time = 0;
            status = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(time, 0);
            _os.write(status, 1);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(time, 0, true);
            _is.read(status, 1, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(time,"time");
            _ds.display(status,"status");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(time, true);
            _ds.displaySimple(status, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        taf::Int32 time;
        taf::Int32 status;
    };
    inline bool operator==(const WnsCmdLogUploadRsp&l, const WnsCmdLogUploadRsp&r)
    {
        return l.time == r.time && l.status == r.status;
    }
    inline bool operator!=(const WnsCmdLogUploadRsp&l, const WnsCmdLogUploadRsp&r)
    {
        return !(l == r);
    }
    int struct_WnsCmdLogUploadRsp_pack(WnsCmdLogUploadRsp * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_WnsCmdLogUploadRsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdLogUploadRsp * pst_struct, pdu_protocol_header * pdu_header);
    int struct_WnsCmdLogUploadRsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WnsCmdLogUploadRsp * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);


}



namespace PUSHAPI
{
    struct stSwitch : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "PUSHAPI.stSwitch";
        }
        static string MD5()
        {
            return "acf6c32c5cc961f170ec1a651a9efe8a";
        }
        stSwitch()
        :iType(0),bOn(true),iSwitchOnTime(0)
        {
        }
        void resetDefautlt()
        {
            iType = 0;
            bOn = true;
            iSwitchOnTime = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(iType, 0);
            _os.write(bOn, 1);
            _os.write(iSwitchOnTime, 2);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(iType, 0, false);
            _is.read(bOn, 1, false);
            _is.read(iSwitchOnTime, 2, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(iType,"iType");
            _ds.display(bOn,"bOn");
            _ds.display(iSwitchOnTime,"iSwitchOnTime");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(iType, true);
            _ds.displaySimple(bOn, true);
            _ds.displaySimple(iSwitchOnTime, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        taf::Int32 iType;
        taf::Bool bOn;
        taf::UInt32 iSwitchOnTime;
    };
    inline bool operator==(const stSwitch&l, const stSwitch&r)
    {
        return l.iType == r.iType && l.bOn == r.bOn && l.iSwitchOnTime == r.iSwitchOnTime;
    }
    inline bool operator!=(const stSwitch&l, const stSwitch&r)
    {
        return !(l == r);
    }
    int struct_stSwitch_pack(stSwitch * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_stSwitch_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, stSwitch * pst_struct, pdu_protocol_header * pdu_header);
    int struct_stSwitch_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, stSwitch * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct STStatus : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "PUSHAPI.STStatus";
        }
        static string MD5()
        {
            return "650a866fd90e12b8477560367f3ded17";
        }
        STStatus()
        :HBTime(0),PushTime(0),Qua(""),AccIp(0),AccPort(0),DeviceToken(""),AccId(0),DeviceInfo(""),Flag(0),LogoffTime(0),SubAppid(0),CoolingTime(0),logUploadTime(0),Wp8Uri("")
        {
        }
        void resetDefautlt()
        {
            HBTime = 0;
            PushTime = 0;
            Qua = "";
            AccIp = 0;
            AccPort = 0;
            DeviceToken = "";
            AccId = 0;
            DeviceInfo = "";
            Flag = 0;
            LogoffTime = 0;
            SubAppid = 0;
            CoolingTime = 0;
            logUploadTime = 0;
            Wp8Uri = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(HBTime, 0);
            _os.write(PushTime, 1);
            _os.write(Qua, 2);
            _os.write(AccIp, 3);
            _os.write(AccPort, 4);
            _os.write(DeviceToken, 5);
            _os.write(AccId, 6);
            _os.write(DeviceInfo, 7);
            _os.write(Flag, 8);
            _os.write(LogoffTime, 9);
            _os.write(SubAppid, 10);
            _os.write(CoolingTime, 11);
            _os.write(logUploadTime, 12);
            _os.write(vecSwitch, 13);
            _os.write(Wp8Uri, 14);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(HBTime, 0, false);
            _is.read(PushTime, 1, false);
            _is.read(Qua, 2, false);
            _is.read(AccIp, 3, false);
            _is.read(AccPort, 4, false);
            _is.read(DeviceToken, 5, false);
            _is.read(AccId, 6, false);
            _is.read(DeviceInfo, 7, false);
            _is.read(Flag, 8, false);
            _is.read(LogoffTime, 9, false);
            _is.read(SubAppid, 10, false);
            _is.read(CoolingTime, 11, false);
            _is.read(logUploadTime, 12, false);
            _is.read(vecSwitch, 13, false);
            _is.read(Wp8Uri, 14, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(HBTime,"HBTime");
            _ds.display(PushTime,"PushTime");
            _ds.display(Qua,"Qua");
            _ds.display(AccIp,"AccIp");
            _ds.display(AccPort,"AccPort");
            _ds.display(DeviceToken,"DeviceToken");
            _ds.display(AccId,"AccId");
            _ds.display(DeviceInfo,"DeviceInfo");
            _ds.display(Flag,"Flag");
            _ds.display(LogoffTime,"LogoffTime");
            _ds.display(SubAppid,"SubAppid");
            _ds.display(CoolingTime,"CoolingTime");
            _ds.display(logUploadTime,"logUploadTime");
            _ds.display(vecSwitch,"vecSwitch");
            _ds.display(Wp8Uri,"Wp8Uri");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(HBTime, true);
            _ds.displaySimple(PushTime, true);
            _ds.displaySimple(Qua, true);
            _ds.displaySimple(AccIp, true);
            _ds.displaySimple(AccPort, true);
            _ds.displaySimple(DeviceToken, true);
            _ds.displaySimple(AccId, true);
            _ds.displaySimple(DeviceInfo, true);
            _ds.displaySimple(Flag, true);
            _ds.displaySimple(LogoffTime, true);
            _ds.displaySimple(SubAppid, true);
            _ds.displaySimple(CoolingTime, true);
            _ds.displaySimple(logUploadTime, true);
            _ds.displaySimple(vecSwitch, true);
            _ds.displaySimple(Wp8Uri, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        taf::UInt32 HBTime;
        taf::UInt32 PushTime;
        std::string Qua;
        taf::UInt32 AccIp;
        taf::UInt32 AccPort;
        std::string DeviceToken;
        taf::Int64 AccId;
        std::string DeviceInfo;
        taf::Int32 Flag;
        taf::UInt32 LogoffTime;
        taf::UInt32 SubAppid;
        taf::UInt32 CoolingTime;
        taf::UInt32 logUploadTime;
        vector<PUSHAPI::stSwitch> vecSwitch;
        std::string Wp8Uri;
    };
    inline bool operator==(const STStatus&l, const STStatus&r)
    {
        return l.HBTime == r.HBTime && l.PushTime == r.PushTime && l.Qua == r.Qua && l.AccIp == r.AccIp && l.AccPort == r.AccPort && l.DeviceToken == r.DeviceToken && l.AccId == r.AccId && l.DeviceInfo == r.DeviceInfo && l.Flag == r.Flag && l.LogoffTime == r.LogoffTime && l.SubAppid == r.SubAppid && l.CoolingTime == r.CoolingTime && l.logUploadTime == r.logUploadTime && l.vecSwitch == r.vecSwitch && l.Wp8Uri == r.Wp8Uri;
    }
    inline bool operator!=(const STStatus&l, const STStatus&r)
    {
        return !(l == r);
    }
    int struct_STStatus_pack(STStatus * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_STStatus_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, STStatus * pst_struct, pdu_protocol_header * pdu_header);
    int struct_STStatus_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, STStatus * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct StatusInfo : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "PUSHAPI.StatusInfo";
        }
        static string MD5()
        {
            return "3980d7ba11a60835a07d173ea36595d0";
        }
        StatusInfo()
        :LastMsgTime(0)
        {
        }
        void resetDefautlt()
        {
            LastMsgTime = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(mapStatus, 0);
            _os.write(LastMsgTime, 1);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(mapStatus, 0, false);
            _is.read(LastMsgTime, 1, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(mapStatus,"mapStatus");
            _ds.display(LastMsgTime,"LastMsgTime");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(mapStatus, true);
            _ds.displaySimple(LastMsgTime, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        map<std::string, PUSHAPI::STStatus> mapStatus;
        taf::UInt32 LastMsgTime;
    };
    inline bool operator==(const StatusInfo&l, const StatusInfo&r)
    {
        return l.mapStatus == r.mapStatus && l.LastMsgTime == r.LastMsgTime;
    }
    inline bool operator!=(const StatusInfo&l, const StatusInfo&r)
    {
        return !(l == r);
    }
    int struct_StatusInfo_pack(StatusInfo * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_StatusInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, StatusInfo * pst_struct, pdu_protocol_header * pdu_header);
    int struct_StatusInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, StatusInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct GetStatusInfo : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "PUSHAPI.GetStatusInfo";
        }
        static string MD5()
        {
            return "eaca2a0c592d19269a1dca659a31efd9";
        }
        GetStatusInfo()
        :Uin(0),Appid(0)
        {
        }
        void resetDefautlt()
        {
            Uin = 0;
            Appid = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(Uin, 0);
            _os.write(Appid, 1);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(Uin, 0, true);
            _is.read(Appid, 1, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(Uin,"Uin");
            _ds.display(Appid,"Appid");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(Uin, true);
            _ds.displaySimple(Appid, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        taf::UInt32 Uin;
        taf::Int32 Appid;
    };
    inline bool operator==(const GetStatusInfo&l, const GetStatusInfo&r)
    {
        return l.Uin == r.Uin && l.Appid == r.Appid;
    }
    inline bool operator!=(const GetStatusInfo&l, const GetStatusInfo&r)
    {
        return !(l == r);
    }
    int struct_GetStatusInfo_pack(GetStatusInfo * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_GetStatusInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, GetStatusInfo * pst_struct, pdu_protocol_header * pdu_header);
    int struct_GetStatusInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, GetStatusInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct DeviceInfo : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "PUSHAPI.DeviceInfo";
        }
        static string MD5()
        {
            return "4939d8b23021c88f29bd89b6f7192958";
        }
        DeviceInfo()
        :uin(0),time(0)
        {
        }
        void resetDefautlt()
        {
            uin = 0;
            time = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(uin, 0);
            _os.write(time, 1);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(uin, 0, true);
            _is.read(time, 1, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(uin,"uin");
            _ds.display(time,"time");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(uin, true);
            _ds.displaySimple(time, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        taf::UInt32 uin;
        taf::UInt32 time;
    };
    inline bool operator==(const DeviceInfo&l, const DeviceInfo&r)
    {
        return l.uin == r.uin && l.time == r.time;
    }
    inline bool operator!=(const DeviceInfo&l, const DeviceInfo&r)
    {
        return !(l == r);
    }
    int struct_DeviceInfo_pack(DeviceInfo * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_DeviceInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, DeviceInfo * pst_struct, pdu_protocol_header * pdu_header);
    int struct_DeviceInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, DeviceInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct PushInfo : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "PUSHAPI.PushInfo";
        }
        static string MD5()
        {
            return "cc86bb5984ba376adb3683728a734a00";
        }
        PushInfo()
        :uiUin(0),iAppid(0),iOp(0),sToken("")
        {
        }
        void resetDefautlt()
        {
            uiUin = 0;
            iAppid = 0;
            iOp = 0;
            sToken = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(uiUin, 0);
            _os.write(iAppid, 1);
            _os.write(iOp, 2);
            _os.write(sToken, 3);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(uiUin, 0, true);
            _is.read(iAppid, 1, true);
            _is.read(iOp, 2, true);
            _is.read(sToken, 3, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(uiUin,"uiUin");
            _ds.display(iAppid,"iAppid");
            _ds.display(iOp,"iOp");
            _ds.display(sToken,"sToken");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(uiUin, true);
            _ds.displaySimple(iAppid, true);
            _ds.displaySimple(iOp, true);
            _ds.displaySimple(sToken, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        taf::UInt32 uiUin;
        taf::Int32 iAppid;
        taf::Int32 iOp;
        std::string sToken;
    };
    inline bool operator==(const PushInfo&l, const PushInfo&r)
    {
        return l.uiUin == r.uiUin && l.iAppid == r.iAppid && l.iOp == r.iOp && l.sToken == r.sToken;
    }
    inline bool operator!=(const PushInfo&l, const PushInfo&r)
    {
        return !(l == r);
    }
    int struct_PushInfo_pack(PushInfo * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_PushInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, PushInfo * pst_struct, pdu_protocol_header * pdu_header);
    int struct_PushInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, PushInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct STMsg : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "PUSHAPI.STMsg";
        }
        static string MD5()
        {
            return "3df5ced5e68e93079c0327310ffae9fb";
        }
        STMsg()
        :AddTime(0),Flag(0),ExpTime(0),MsgTag("")
        {
        }
        void resetDefautlt()
        {
            AddTime = 0;
            Flag = 0;
            ExpTime = 0;
            MsgTag = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(AddTime, 0);
            _os.write(Data, 1);
            _os.write(Flag, 2);
            _os.write(ExpTime, 3);
            _os.write(MsgTag, 4);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(AddTime, 0, true);
            _is.read(Data, 1, true);
            _is.read(Flag, 2, false);
            _is.read(ExpTime, 3, false);
            _is.read(MsgTag, 4, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(AddTime,"AddTime");
            _ds.display(Data,"Data");
            _ds.display(Flag,"Flag");
            _ds.display(ExpTime,"ExpTime");
            _ds.display(MsgTag,"MsgTag");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(AddTime, true);
            _ds.displaySimple(Data, true);
            _ds.displaySimple(Flag, true);
            _ds.displaySimple(ExpTime, true);
            _ds.displaySimple(MsgTag, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        taf::UInt32 AddTime;
        vector<taf::Char> Data;
        taf::Char Flag;
        taf::UInt32 ExpTime;
        std::string MsgTag;
    };
    inline bool operator==(const STMsg&l, const STMsg&r)
    {
        return l.AddTime == r.AddTime && l.Data == r.Data && l.Flag == r.Flag && l.ExpTime == r.ExpTime && l.MsgTag == r.MsgTag;
    }
    inline bool operator!=(const STMsg&l, const STMsg&r)
    {
        return !(l == r);
    }
    int struct_STMsg_pack(STMsg * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_STMsg_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, STMsg * pst_struct, pdu_protocol_header * pdu_header);
    int struct_STMsg_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, STMsg * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct MsgInfo : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "PUSHAPI.MsgInfo";
        }
        static string MD5()
        {
            return "f46bcdd74e738f224d1e2039343c934a";
        }
        MsgInfo()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(vecMsg, 0);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(vecMsg, 0, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(vecMsg,"vecMsg");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(vecMsg, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        vector<PUSHAPI::STMsg> vecMsg;
    };
    inline bool operator==(const MsgInfo&l, const MsgInfo&r)
    {
        return l.vecMsg == r.vecMsg;
    }
    inline bool operator!=(const MsgInfo&l, const MsgInfo&r)
    {
        return !(l == r);
    }
    int struct_MsgInfo_pack(MsgInfo * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_MsgInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, MsgInfo * pst_struct, pdu_protocol_header * pdu_header);
    int struct_MsgInfo_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, MsgInfo * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct Push : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "PUSHAPI.Push";
        }
        static string MD5()
        {
            return "c7747f606d95d2c98846adf9cdd0bcca";
        }
        Push()
        :ptime(0),Mark(""),sUID("")
        {
        }
        void resetDefautlt()
        {
            ptime = 0;
            Mark = "";
            sUID = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(UID, 0);
            _os.write(ptime, 1);
            _os.write(vecMsg, 2);
            _os.write(Mark, 3);
            _os.write(sUID, 4);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(UID, 0, false);
            _is.read(ptime, 1, false);
            _is.read(vecMsg, 2, false);
            _is.read(Mark, 3, false);
            _is.read(sUID, 4, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(UID,"UID");
            _ds.display(ptime,"ptime");
            _ds.display(vecMsg,"vecMsg");
            _ds.display(Mark,"Mark");
            _ds.display(sUID,"sUID");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(UID, true);
            _ds.displaySimple(ptime, true);
            _ds.displaySimple(vecMsg, true);
            _ds.displaySimple(Mark, true);
            _ds.displaySimple(sUID, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        vector<taf::Char> UID;
        taf::UInt32 ptime;
        vector<PUSHAPI::STMsg> vecMsg;
        std::string Mark;
        std::string sUID;
    };
    inline bool operator==(const Push&l, const Push&r)
    {
        return l.UID == r.UID && l.ptime == r.ptime && l.vecMsg == r.vecMsg && l.Mark == r.Mark && l.sUID == r.sUID;
    }
    inline bool operator!=(const Push&l, const Push&r)
    {
        return !(l == r);
    }
    int struct_Push_pack(Push * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_Push_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, Push * pst_struct, pdu_protocol_header * pdu_header);
    int struct_Push_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, Push * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct PushRsp : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "PUSHAPI.PushRsp";
        }
        static string MD5()
        {
            return "2c8b2fc37b98ba1e6b97d4069acf1d07";
        }
        PushRsp()
        :ptime(0),Mark(""),is_bgd(0),sUID("")
        {
        }
        void resetDefautlt()
        {
            ptime = 0;
            Mark = "";
            is_bgd = 0;
            sUID = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(UID, 0);
            _os.write(ptime, 1);
            _os.write(Mark, 3);
            _os.write(is_bgd, 4);
            _os.write(sUID, 5);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(UID, 0, false);
            _is.read(ptime, 1, false);
            _is.read(Mark, 3, false);
            _is.read(is_bgd, 4, false);
            _is.read(sUID, 5, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(UID,"UID");
            _ds.display(ptime,"ptime");
            _ds.display(Mark,"Mark");
            _ds.display(is_bgd,"is_bgd");
            _ds.display(sUID,"sUID");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(UID, true);
            _ds.displaySimple(ptime, true);
            _ds.displaySimple(Mark, true);
            _ds.displaySimple(is_bgd, true);
            _ds.displaySimple(sUID, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        vector<taf::Char> UID;
        taf::UInt32 ptime;
        std::string Mark;
        taf::Char is_bgd;
        std::string sUID;
    };
    inline bool operator==(const PushRsp&l, const PushRsp&r)
    {
        return l.UID == r.UID && l.ptime == r.ptime && l.Mark == r.Mark && l.is_bgd == r.is_bgd && l.sUID == r.sUID;
    }
    inline bool operator!=(const PushRsp&l, const PushRsp&r)
    {
        return !(l == r);
    }
    int struct_PushRsp_pack(PushRsp * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_PushRsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, PushRsp * pst_struct, pdu_protocol_header * pdu_header);
    int struct_PushRsp_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, PushRsp * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct IOSPush : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "PUSHAPI.IOSPush";
        }
        static string MD5()
        {
            return "4da4a3702526d1760f11ec5eeced1433";
        }
        IOSPush()
        :uiUin(0),uiSeq(0),iAppid(0),sDeviceToken(""),sPayload("")
        {
        }
        void resetDefautlt()
        {
            uiUin = 0;
            uiSeq = 0;
            iAppid = 0;
            sDeviceToken = "";
            sPayload = "";
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(uiUin, 0);
            _os.write(uiSeq, 1);
            _os.write(iAppid, 2);
            _os.write(sDeviceToken, 3);
            _os.write(sPayload, 4);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(uiUin, 0, true);
            _is.read(uiSeq, 1, true);
            _is.read(iAppid, 2, true);
            _is.read(sDeviceToken, 3, true);
            _is.read(sPayload, 4, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(uiUin,"uiUin");
            _ds.display(uiSeq,"uiSeq");
            _ds.display(iAppid,"iAppid");
            _ds.display(sDeviceToken,"sDeviceToken");
            _ds.display(sPayload,"sPayload");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(uiUin, true);
            _ds.displaySimple(uiSeq, true);
            _ds.displaySimple(iAppid, true);
            _ds.displaySimple(sDeviceToken, true);
            _ds.displaySimple(sPayload, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        taf::UInt32 uiUin;
        taf::UInt32 uiSeq;
        taf::Int32 iAppid;
        std::string sDeviceToken;
        std::string sPayload;
    };
    inline bool operator==(const IOSPush&l, const IOSPush&r)
    {
        return l.uiUin == r.uiUin && l.uiSeq == r.uiSeq && l.iAppid == r.iAppid && l.sDeviceToken == r.sDeviceToken && l.sPayload == r.sPayload;
    }
    inline bool operator!=(const IOSPush&l, const IOSPush&r)
    {
        return !(l == r);
    }
    int struct_IOSPush_pack(IOSPush * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_IOSPush_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, IOSPush * pst_struct, pdu_protocol_header * pdu_header);
    int struct_IOSPush_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, IOSPush * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct WINMsg : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "PUSHAPI.WINMsg";
        }
        static string MD5()
        {
            return "a13cd6de8162637eed6572f567dc5833";
        }
        WINMsg()
        :AddTime(0),sMsg(""),iCount(0)
        {
        }
        void resetDefautlt()
        {
            AddTime = 0;
            sMsg = "";
            iCount = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(AddTime, 0);
            _os.write(sMsg, 1);
            _os.write(iCount, 2);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(AddTime, 0, true);
            _is.read(sMsg, 1, true);
            _is.read(iCount, 2, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(AddTime,"AddTime");
            _ds.display(sMsg,"sMsg");
            _ds.display(iCount,"iCount");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(AddTime, true);
            _ds.displaySimple(sMsg, true);
            _ds.displaySimple(iCount, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        taf::UInt32 AddTime;
        std::string sMsg;
        taf::UInt32 iCount;
    };
    inline bool operator==(const WINMsg&l, const WINMsg&r)
    {
        return l.AddTime == r.AddTime && l.sMsg == r.sMsg && l.iCount == r.iCount;
    }
    inline bool operator!=(const WINMsg&l, const WINMsg&r)
    {
        return !(l == r);
    }
    int struct_WINMsg_pack(WINMsg * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_WINMsg_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WINMsg * pst_struct, pdu_protocol_header * pdu_header);
    int struct_WINMsg_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WINMsg * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);

    struct WINPush : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "PUSHAPI.WINPush";
        }
        static string MD5()
        {
            return "0be293d69a237bcbd873d221aa42fcc0";
        }
        WINPush()
        :uiUin(0),uiSeq(0),iAppid(0),sWp8Uri(""),sUID(""),iSubAppid(0)
        {
        }
        void resetDefautlt()
        {
            uiUin = 0;
            uiSeq = 0;
            iAppid = 0;
            sWp8Uri = "";
            sUID = "";
            iSubAppid = 0;
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(uiUin, 0);
            _os.write(uiSeq, 1);
            _os.write(iAppid, 2);
            _os.write(sWp8Uri, 3);
            _os.write(vecMsg, 4);
            _os.write(sUID, 5);
            _os.write(iSubAppid, 6);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(uiUin, 0, true);
            _is.read(uiSeq, 1, true);
            _is.read(iAppid, 2, true);
            _is.read(sWp8Uri, 3, true);
            _is.read(vecMsg, 4, true);
            _is.read(sUID, 5, true);
            _is.read(iSubAppid, 6, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(uiUin,"uiUin");
            _ds.display(uiSeq,"uiSeq");
            _ds.display(iAppid,"iAppid");
            _ds.display(sWp8Uri,"sWp8Uri");
            _ds.display(vecMsg,"vecMsg");
            _ds.display(sUID,"sUID");
            _ds.display(iSubAppid,"iSubAppid");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(uiUin, true);
            _ds.displaySimple(uiSeq, true);
            _ds.displaySimple(iAppid, true);
            _ds.displaySimple(sWp8Uri, true);
            _ds.displaySimple(vecMsg, true);
            _ds.displaySimple(sUID, true);
            _ds.displaySimple(iSubAppid, false);
            return _os;
        }
        int Encode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_len = pdu_header?*pi_buff_len:0;
                int i_ret = 0;
                if (pdu_header && (i_ret = ::pdu_header_pack1(pdu_header, pui_buff, (uint32_t *)&i_len)) != 0) { return i_ret; }

                taf::JceOutputStream<taf::BufferWriterBuff> os;
                os.setBuffer(reinterpret_cast<char *>(pui_buff + i_len), *pi_buff_len - i_len);
                this->writeTo(os);
                i_len = i_len + static_cast<int>(os.getLength());
                if (pdu_header && (i_ret = pdu_header_pack2(pui_buff, (uint32_t *)pi_buff_len, (uint32_t *)&i_len)) != 0) { return i_ret; }
                *pi_buff_len = i_len;
            }
            catch (taf::JceNotEnoughBuff & e)
            {
            	 return -100;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	 return -104;
            }
            catch (...)
            {
            	 return -1;
            }
            return 0;
        }

        int Decode(uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header)
        {
            try
            {
                int i_ret = 0;
                int i_wup_len = pdu_header?*pi_buff_len:0;
                int i_end_len = 0;
                if (pdu_header && (i_ret = pdu_header_unpack(pui_buff, (uint32_t *)&i_wup_len, pdu_header, (uint32_t *)&i_end_len)) != 0) return i_ret;

                taf::JceInputStream<taf::MapBufferReader> is;
                is.setBuffer(reinterpret_cast<const char*>(pui_buff + i_wup_len), static_cast<size_t>(*pi_buff_len - i_wup_len - i_end_len));

                this->readFrom(is);
            }
            catch (taf::JceDecodeMismatch & e)
            {
            	return -101;
            }
            catch (taf::JceDecodeInvalidValue & e)
            {
            	return -104;
            }
            catch (taf::JceDecodeRequireNotExist & e)
            {
            	return -103;
            }
            catch (...)
            {
            	return -1;
            }
            return 0;
        }
    public:
        taf::UInt32 uiUin;
        taf::UInt32 uiSeq;
        taf::Int32 iAppid;
        std::string sWp8Uri;
        vector<PUSHAPI::WINMsg> vecMsg;
        std::string sUID;
        taf::Int32 iSubAppid;
    };
    inline bool operator==(const WINPush&l, const WINPush&r)
    {
        return l.uiUin == r.uiUin && l.uiSeq == r.uiSeq && l.iAppid == r.iAppid && l.sWp8Uri == r.sWp8Uri && l.vecMsg == r.vecMsg && l.sUID == r.sUID && l.iSubAppid == r.iSubAppid;
    }
    inline bool operator!=(const WINPush&l, const WINPush&r)
    {
        return !(l == r);
    }
    int struct_WINPush_pack(WINPush * pst_struct, uint8_t * pui_buff, int32_t * pi_buff_len, pdu_protocol_header * pdu_header);
    int struct_WINPush_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WINPush * pst_struct, pdu_protocol_header * pdu_header);
    int struct_WINPush_unpack(uint8_t * pui_buff, int32_t * pi_buff_len, WINPush * pst_struct, pdu_protocol_header * pdu_header, uint8_t * pui_mapbuff, int32_t * pi_mapbuff_len);


}



#endif
